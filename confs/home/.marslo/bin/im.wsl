#!/usr/bin/env bash
# shellcheck disable=SC2164,SC2086

function mkcd() { mkdir -p $1 && cd $1; }
function cdls() { cd $1 && ls; }
function cdla() { cd $1 && la; }
function chmv() { sudo mv $1 $2; sudo chown -R appadmin:appadmin $2; }
function cha() { sudo chown -R appadmin:appadmin $1; }
# shellcheck disable=SC1091
function rcsource() { source $HOME/.marslo/.marslorc; }
function gbl() { git for-each-ref --sort=-committerdate --format='%(committerdate) %(authorname) %(refname)' refs/remotes/origin/ | grep -e ."$*" | head -n 10; }
# export cl=`p4 change -o | sed 's/<enter description here>/"Change list description"/' | sed '/^#/d' | sed '/^$/d' | p4 change -i | cut -d ' ' -f 2`
function p4nc() { p4 change -o | sed '/^#/d' | sed '/^$/d' | sed "s|Description: |Description: $*|" | sed "s|JIRA ID.*$|JIRA ID: APPSOL-00000|" | sed "s|Review.*$|Review: self-review|" | sed "s/+$//" | p4 change -i; }
function p4blame() { FILE="$1"; LINE="$2"; p4 annotate -cq "${FILE}" | sed "${LINE}q;d" | cut -f1 -d: | xargs p4 describe -s | sed -e '/Affected files/,$d'; }
function p4cd() { unset P4DIFF; p4 opened -c $1 | awk -F' ' '{print $1}' | p4 -x - -z tag diff -du > $1.diff; export P4DIFF=vimdiff; }
function dir() { find . -iname "$@" -print0 | xargs -r0 ls -altr | awk '{print; total += $5}; END {print "total size: ", total}'; }

function pydict() {
  currentDir=$(pwd)
  cd ~/.vim/bundle/pydiction
  python pydiction.py "$@"
  cd $currentDir
}

# marslo grep
function mg() {
  # shellcheck disable=SC1078,SC1079
  usage="""mg - marslo grep - combined find and grep to quick find keywords
  \nUSAGE:
  \n\t$(c sY)\$ mg [OPT] [NUM] KEYWORD [<PATHA>]$(c)
  \nExample:
  \n\t$(c G)\$ mg 'hello'
  \t\$ mg i 'hello' ~/.marslo
  \t\$ mg ic 3 'hello' ~/.marslo$(c)
  \nOPT:
  \n\t$(c B)i$(c) : ignore case
  \t$(c B)f$(c) : find file name only
  \t$(c B)a <num>$(c) : print <num> lines of trailing context after matching lines
  \t$(c B)b <num>$(c) : print <num> lines of leading context before matching lines
  \t$(c B)c <num>$(c) : print <num> lines of output context
  """

  kw=''
  p='.'
  opt='-n -H -E --color=always'

  if [ 0 -eq $# ]; then
    echo -e "${usage}"
  else
    case $1 in
      [wW] | [iI] )
        opt="${opt} -$(echo $1 | tr '[:upper:]' '[:lower:]')"
        [ 2 -le $# ] && kw="$2"
        [ 3 -eq $# ] && p="$3"
        ;;
      [fF] )
        opt="${opt} -l"
        [ 2 -le $# ] && kw="$2"
        [ 3 -eq $# ] && p="$3"
        ;;
      [iI][fF] | [fF][iI] )
        opt="${opt} -i -l"
        [ 2 -le $# ] && kw="$2"
        [ 3 -eq $# ] && p="$3"
        ;;
      [aA] | [bB] | [cC] | [iI][aA] | [iI][bB] | [iI][cC] | [aA][iI] | [bB][iI] | [cC][iI] )
        # line = -A $2 | -B $2 | -C $2
        line="-$(echo $1 | awk -F'[iI]' '{print $1,$2}' | sed -e 's/^[[:space:]]*//' | tr '[:lower:]' '[:upper:]') $2"
        opt="${opt} -i ${line}"
        [ 3 -le $# ] && kw="$3"
        [ 4 -eq $# ] && p="$4"
        ;;
      * )
        kw="$1"
        [ 2 -le $# ] && p="$2"
        ;;
    esac

    if [ -n "${kw}" ]; then
      # or using + instead of ; details: https://unix.stackexchange.com/a/43743/29178
      # shellcheck disable=SC2125,SC2027
      cmd="""find "${p}" -type f -not -path "*git/*" -exec grep ${opt} "${kw}" {} ;"""
      find "${p}" -type f -not -path "*git/*" -exec grep ${opt} "${kw}" {} \; \
        || echo -e """\n$(c Y)ERROR ON COMMAND:$(c)\n\t$(c R)$ ${cmd}$(c) """
    else
      echo -e "${usage}"
    fi
  fi
}

# find file
ff() {
  # shellcheck disable=SC1078,SC1079
  usage="""USAGE:
  \n\t$(c sY)\$ ff <FILENAME> [<PATH>]$(c)
  \nExample:
  \n\t$(c G)\$ ff myfile.txt
  \t\$ ff myfile.txt ~/.marslo$(c)
  """

  if [ 0 -eq $# ]; then
    echo -e "${usage}"
  else
    p='.'
    [ 2 -eq $# ] && p="$2"
    find "${p}" -type f -not -path "\'*git/*\'" -iname "*${1}*"
  fi
}

# marslo sed
function ms() {
  # shellcheck disable=SC1078,SC1079
  usage="""msed - marslo sed - sed all key words in the path
  \n$(c s)USAGE:$(c)
  \n\t$(c sY)\$ msed [OPT] <ORIGIN_STRING> <NEW_STRING> [PATH]$(c)
  \nExample:
  \n\t$(c G)\$ msed mystr MY_STR
  \t$(c G)\$ msed re '^.*\(.*\).*$' 'MY_STR'
  \t\$ msed mystr MY_STR ~/.marslo$(c)
  \nOPT:
  \n\t$(c B)r$(c) : use extended regular expressions in the script
  \t$(c B)e$(c) : add the script to the commands to be executed
  """

  p='.'
  sw=''     # source word
  tw=''     # target word
  opt='-i'

  if [ 2 -le $# ]; then
    case $1 in
      [rR] )
        opt="${opt} -r"
        [ 3 -le $# ] && sw="$2" && tw="$3"
        [ 4 -eq $# ] && p="$4"
        ;;
      [rR][eE] | [eE][rR] )
        opt="${opt} -r -e"
        [ 3 -le $# ] && sw="$2" && tw="$3"
        [ 4 -eq $# ] && p="$4"
        ;;
      * )
        [ 2 -le $# ] && sw="$1" && tw="$2"
        [ 3 -le $# ] && p="$3"
        ;;
    esac
  fi

  if [ -n "${sw}" ] && [ -n "${tw}" ]; then
    # shellcheck disable=SC2125,SC2027
    cmd="""find "${p}" -type f -not -path "*git/*" -exec sed ${opt} "s,${sw},${tw},g" {} ;"""
    ${cmd} \
      || echo -e """\n$(c Y)ERROR ON COMMAND:$(c)\n\t$(c R)$ ${cmd}$(c) """
  else
    echo -e "${usage}"
  fi
}

function bd() {
  USER='svc_appbld'
  DOMAIN='engba'
  TYPE='appbuilder'

  # shellcheck disable=SC2048
  args=$(getopt rcd $*)
  if test $? != 0
  then
    echo -e 'Usage: [-r[c[d]]] HostnumVMnum
    -r: root
    -c: cdc builder (engma.veritas.com)
    -d: dev builder (appreldev)
    '
  else
    set -- $args

    for opt; do
      case ${opt} in
        -r) USER='root' ;;
        -c) DOMAIN='engma' ;;
        -d) TYPE='appreldev' ;;
      esac
    done

    for VAR in "$@"; do true; done
    HOST=${VAR:0:2}
    VM=${VAR:2}

    /usr/bin/ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -i /home/marslo/.marslo/Marslo/Tools/Softwares/sshkey/Marslo\@Appliance ${USER}@${TYPE}${HOST}-vm${VM}.${DOMAIN}.veritas.com
  fi
}

function mdiff() {
  echo -e " [${1##*/}]\t\t\t\t\t\t\t[${2##*/}]"
  diff -y --suppress-common-lines $1 $2
}

function dir-h() {
  find . -iname "$@" -exec ls -lthrNF --color=always {} \;
  find . -iname "$@" -print0 | xargs -r0 du -csh| tail -n 1
}

function ccker() {
  pushd . || true
  cd ~/myworks/appliance/automation/robot/branches/dev_main
  python utility/checkers/CodeChecker.py --check_all
  popd || true
}

function rcsync() {
  SITE="Jira Confluence Jenkins Gitlab Artifactory Sonar Slave"
  HNAME=$(hostname | tr '[:upper:]' '[:lower:]')
  for i in $SITE; do
    CURNAME=$(echo $i | tr '[:upper:]' '[:lower:]')
    if [ "$HNAME" != $CURNAME ]; then
      echo ------------------- $i ---------------------;
      pushd $PWD
      cd /home/appadmin
      rsync -avzrlpgoD --exclude=.marslo/Tools --exclude=.vim/view --exclude=.vim/cache --exclude=.vim/.netrwhist --exclude=.ssh/known_hosts -e 'ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null ' .marslo .vim .vimrc .inputrc .tmux.conf appadmin@$i:~/
      popd
    fi
  done
}

function gitFetch() {
  GITDIR=${1%%/}
  GITBRANCH=$2
  ISStashed=false
  pushd . > /dev/null
  cd "${GITDIR}"
  echo -e "\\033[34m=== ${GITDIR} ===\\033[0m"

  if git rev-parse --git-dir > /dev/null 2>&1; then
    utFiles=$(git ls-files --others --exclude-standard)
    mdFiles=$(git ls-files --modified)
    cBranch=$(git rev-parse --abbrev-ref HEAD)
    [[ -n "${utFiles}" ]] && echo -e "\\033[35mUNTRACKED FILES in ${cBranch}: ${utFiles}\\033[0m"

    if ! git branch -a | ${GREP} ${GITBRANCH} > /dev/null 2>&1; then
      GITBRANCH=master
    fi
    echo -e "\\033[33m-> ${GITBRANCH}\\033[0m"

    # checkout branch to $GITBRANCH
    if [[ ! "${cBranch}" = "${GITBRANCH}" ]]; then
      if [[ -n "${mdFiles}" ]]; then
        echo -e "\\033[31mGIT STASH: ${GITDIR} : ${cBranch} !!\\033[0m"
        git stash save "auto-stashed by gitFetch command"
        ISStashed=true
      fi
      git checkout "${GITBRANCH}"
    fi

    # remove the local branch if the branch has been deleted in remote
    if git remote prune origin --dry-run | ${GREP} prune; then
      prBranch=$(git remote prune origin --dry-run | ${GREP} prune | awk -F'origin/' '{print $NF}')
      if [ "${cBranch}" = "${prBranch}" ] && [ -z "${mdFiles}" ]; then
        echo -e "\\033[32mThe current branch ${cBranch} has been rmeoved in remote. And the current branch has no modified files!\\033[0m"
        ISStashed=false
      fi

      if git branch | ${GREP} "${prBranch}"; then
        echo -e "\\033[35mREMOVE LOCAL BRNACH ${prBranch}, due to ${prBranch} has been rmeoved in remote.\\033[0m"
        if ! git branch -D "${prBranch}"; then
          echo -e "\\033[32mWARNING: REMOVE LOCAL BRANCH ${prBranch} failed!!\\033[0m"
        fi
      fi
    fi

    # git fetchall on ${GITBRANCH}
    git remote prune origin
    git fetch origin --prune
    git fetch --all --force
    git merge --all --progress

    # restore the current working branch
    if ${ISStashed}; then
      git checkout "${cBranch}"
      git stash pop
      echo -e "\\033[35mGIT STASH POP: ${GITDIR} : ${cBranch}\\033[0m"
    fi
  else
    echo -e "\\033[33mNOT Git Repo!!\\033[0m"
  fi
  popd > /dev/null
}

function fetchdir() {
  myDir="$1"
  for i in $(${LS} -1d ${myDir%%/}/); do
    gitFetch "$i" "dev"
  done
}

function fetchall() {
  if [ 1 -eq $# ]; then
    brName=$1
  else
    brName="dev"
  fi
  # shellcheck disable=SC2035
  for i in $(${LS} -1d */); do
    gitFetch "$i" "$brName"
  done
}

# proxy clear
function pclr() {
  PROXY_ENV="http_proxy ftp_proxy https_proxy all_proxy socks_proxy HTTP_PROXY HTTPS_PROXY FTP_PROXY ALL_PROXY SOCKS_PROXY"
  for envvar in $PROXY_ENV; do unset "$envvar"; done
  echo -e "$(c sM)all proxy environment variable has been removed.$(c)"
}

# proxy setup
function pset() {
  # myproxy=$(echo $1 | sed -n 's/\([0-9]\{1,3\}.\)\{4\}:\([0-9]\+\)/&/p')
  if [ 0 -eq $# ]; then
    myproxy='http://127.0.0.1:8081'
  else
    myproxy=$*
  fi
  # PROXY_ENV="http_proxy ftp_proxy https_proxy all_proxy socks_proxy HTTP_PROXY HTTPS_PROXY FTP_PROXY ALL_PROXY SOCKS_PROXY"
  PROXY_ENV='http_proxy ftp_proxy https_proxy all_proxy HTTP_PROXY HTTPS_PROXY FTP_PROXY ALL_PROXY'
  for envvar in $PROXY_ENV; do
    export "$envvar"="$myproxy"
  done
  echo -e "$(c sG)proxy has been all set as $myproxy.$(c)"
}

function 256color() {
  for i in {0..255}; do
    echo -e "\e[38;05;${i}m█${i}";
    done | column -c 80 -s ' ';
  echo -e "\e[m"
}

## smart vim
function vim() {
  if [[ 0 -eq $# ]]; then
    fzf --multi --bind="enter:become($(which -a vim | head -1) {+})"
  else
    $(which -a vim | head -1) -u $HOME/.vimrc "$@"
  fi
}

## preview contents via `$ cd **<tab>`: https://pragmaticpineapple.com/four-useful-fzf-tricks-for-your-terminal/
_fzf_comprun() {
  local command=$1
  shift

  case "$command" in
    cd)           fzf "$@" --preview 'tree -C {} | head -200' ;;
    *)            fzf "$@" ;;
  esac
