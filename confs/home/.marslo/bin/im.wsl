#!/usr/bin/env bash
# shellcheck disable=SC2164,SC2086
# =============================================================================
#     FileName : im.wsl
#       Author : marslo.jiao@gmail.com
#         Desc : im for wsl
#      Created : 2012
#   LastChange : 2023-10-08 05:19:48
# =============================================================================

# shellcheck disable=SC1091
function rcsource() { source $HOME/.marslo/.marslorc; }
function mkcd() { mkdir -p $1 && cd $1; }
function cdls() { cd $1 && ls; }
function cdla() { cd $1 && la; }
function gbl()  { git for-each-ref --sort=-committerdate --format='%(committerdate) %(authorname) %(refname)' refs/remotes/origin/ | grep -e ."$*" | head -n 10; }
function dir()  { find . -iname "$@" -print0 | xargs -r0 ls -altr | awk '{print; total += $5}; END {print "total size: ", total}'; }

function contains() {
  standard=$1
  sub=$2
  for _s in $(echo "${sub}" | fold -w1); do
    [[ ! "${standard}" =~ ${_s} ]] && return 1
  done
  return 0
}

# return 0 if found $2
function hasit() {
  standard=$1
  sub=$2
  result=1
  for _s in $(echo "${sub}" | fold -w1); do
    [[ "${standard}" =~ "${_s}" ]] && result=0
  done
  return ${result}
}

# marslo grep
function mg() {
  set -f
  usage="""\tMG - $(c B)M$(c)ARSLO $(c M)G$(c)REP - COMBINED FIND AND GREP TO QUICK FIND KEYWORDS
  \nSYNOPSIS
  \t$(c sY)\$ mg [i|I] [f|F] [m|M] [w|W]
  \t     [a|A <num>] [b|B <num>] [c|C <num>]
  \t     [e|E <suffix>]
  \t     KEYWORD [<PATHA>]$(c)
  \nEXAMPLE
  \n\t$(c G)\$ mg 'hello'
  \t\$ mg i 'hello' ~/.marslo
  \t\$ mg iC 3 'hello' ~/.marslo$(c)
  \nOPT
  \t$(c B)i$(c)            : ignore case
  \t$(c B)f$(c)            : find file name only
  \t$(c B)m$(c)            : find markdown only
  \t$(c B)w$(c)            : match word only
  \t$(c B)a|A <num>$(c)    : print <num> lines of trailing context after matching lines
  \t$(c B)b|B <num>$(c)    : print <num> lines of leading context before matching lines
  \t$(c B)c|C <num>$(c)    : print <num> lines of output context
  \t$(c B)e|E <suffix>$(c) : [e]xclude <suffix> (filetype)
  """

  keyword=''
  path='.'
  debug=1
  grepOpt='--color=always -n -H'
  gitOptAdditional='-E'
  name=''
  param=$( tr '[:upper:]' '[:lower:]' <<< "$1" )

  contains 'ifmwabce' "${param}"
  # shellcheck disable=SC2034
  paramValid=$?

  if [[ 0 -eq $# ]] ; then
    echo -e "${usage}"
    return
  elif [[ 1 -eq $# ]]; then
    keyword="$1"
  elif [[ 2 -eq $# ]] && [[ "$2" =~ '/' || "$2" =~ '.' ]]; then
    keyword="$1"
    path="$2"
  else
    [[ "${param}" =~ 'i' ]] && grepOpt+=' -i'            && params='threeMost'
    [[ "${param}" =~ 'w' ]] && grepOpt+=' -w'            && params='threeMost'
    [[ "${param}" =~ 'f' ]] && grepOpt+=' -l'            && params='threeMost'
    [[ "${param}" =~ 'm' ]] && name='-iname *.md'        && params='threeMost'
    [[ "${param}" =~ 'd' ]] && debug=0                   && params='threeMost'
    [[ "$1" =~ 'a'       ]] && grepOpt+=" -i -A $2"      && params='fourMost'
    [[ "$1" =~ 'b'       ]] && grepOpt+=" -i -B $2"      && params='fourMost'
    [[ "$1" =~ 'c'       ]] && grepOpt+=" -i -C $2"      && params='fourMost'
    [[ "$1" =~ 'A'       ]] && grepOpt+=" -A $2"         && params='fourMost'
    [[ "$1" =~ 'B'       ]] && grepOpt+=" -B $2"         && params='fourMost'
    [[ "$1" =~ 'C'       ]] && grepOpt+=" -C $2"         && params='fourMost'
    [[ "${param}" =~ 'e' ]] && name='-not -iname *.'"$2" && params='fourMost'

    if [ 'threeMost' == "${params}" ]; then
      [[ 2 -le $# ]] && keyword="$2"
      [[ 3 -eq $# ]] && path="$3"
    elif [ 'fourMost' == "${params}" ]; then
      [[ 3 -le $# ]] && keyword="$3"
      [[ 4 -eq $# ]] && path="$4"
    fi

  fi

  if [ -n "${keyword}" ]; then

    hasit '\' "${keyword}"
    if [[ 0 = $? ]]; then
      grepOpt+=" ${gitOptAdditional}"
    fi

    # or using + instead of ; details: https://unix.stackexchange.com/a/43743/29178
    # shellcheck disable=SC2027,SC2125
    cmd=" find '${path}'"
    cmd+=" -type f"
    cmd+=" ${name}"
    cmd+=" -not -path '*.git/*'"
    cmd+=" -not -path '*node_modules/*'"
    cmd+=" -exec ${GREP} ${grepOpt} '${keyword}' {} \;"

    # find "${path}" \
         # -type f \
         # ${name} \
         # -not -path '*git/*' \
         # -not -path '*node_modules/*' \
         # -exec ${GREP} ${grepOpt} "${keyword}" {} \; ||

    [[ 0 -eq debug ]] &&
        echo -e """
          $(c G)DEBUG INFO:$(c)
                 $(c Y)\$1$(c) : $(c C)'${1}'$(c)
                 $(c Y)\$2$(c) : $(c C)'${2:-}'$(c)
                 $(c Y)\$3$(c) : $(c C)'${3:-}'$(c)
                 $(c Y)\$4$(c) : $(c C)'${4:-}'$(c)
            $(c Y)keyword$(c) : $(c C)'${keyword}'$(c)
               $(c Y)path$(c) : $(c C)'${path:-}'$(c)
            $(c Y)grepOpt$(c) : $(c C)'${grepOpt}'$(c)
                $(c Y)cmd$(c) : $(c C)\$${cmd}$(c)
         """

    eval "${cmd}" ||
         echo -e """\n$(c Y)ERROR ON COMMAND:$(c)\n\t$(c R)$ ${cmd}$(c) """

  elif [ 0 -ne $# ]; then
    echo -e "${usage}"
  fi

  set +f
}

# find file
function ff() {
  # shellcheck disable=SC1078,SC1079
  usage="""\t$(c B)f$(c)ind $(c M)f$(c)ile(s)
  \nSYNOPSIS
  \n\t$(c sY)\$ ff <FILENAME> [<PATH>]$(c)
  \nEXAMPLE
  \n\t$(c G)\$ ff myfile.txt
  \t\$ ff myfile.txt ~/.marslo$(c)
  """

  if [ 0 -eq $# ]; then
    echo -e "${usage}"
  else
    path='.'
    [ 2 -eq $# ] && path="$2"
    find "${path}" -type f -not -path "\'*git/*\'" -iname "*${1}*"
  fi
}

# marslo sed
function ms() {
  # shellcheck disable=SC1078,SC1079
  usage="""msed - marslo sed - sed all key words in the path
  \n$(c s)SYNOPSIS$(c)
  \n\t$(c sY)\$ msed [OPT] <ORIGIN_STRING> <NEW_STRING> [PATH]$(c)
  \nEXAMPLE
  \n\t$(c G)\$ msed mystr MY_STR
  \t$(c G)\$ msed re '^.*\(.*\).*$' 'MY_STR'
  \t\$ msed mystr MY_STR ~/.marslo$(c)
  \nOPT:
  \n\t$(c B)r$(c) : use extended regular expressions in the script
  \t$(c B)e$(c) : add the script to the commands to be executed
  """

  path='.'
  sw=''     # source word
  tw=''     # target word
  opt='-i'

  if [ 2 -le $# ]; then
    case $1 in
      [rR] )
        opt="${opt} -r"
        [ 3 -le $# ] && sw="$2" && tw="$3"
        [ 4 -eq $# ] && path="$4"
        ;;
      [rR][eE] | [eE][rR] )
        opt="${opt} -r -e"
        [ 3 -le $# ] && sw="$2" && tw="$3"
        [ 4 -eq $# ] && path="$4"
        ;;
      * )
        [ 2 -le $# ] && sw="$1" && tw="$2"
        [ 3 -le $# ] && path="$3"
        ;;
    esac
  fi

  if [ -n "${sw}" ] && [ -n "${tw}" ]; then
    # shellcheck disable=SC2125,SC2027
    cmd="""find "${path}" -type f -not -path "*git/*" -exec sed ${opt} \"s:${sw}:${tw}:g\" -i {} \;"""
    eval "${cmd}" ||
         echo -e """\n$(c Y)ERROR ON COMMAND:$(c)\n\t$(c R)$ ${cmd}$(c) """
  else
    echo -e "${usage}"
  fi
}

# proxy clear
function pclr(){
  pEnv="http_proxy ftp_proxy https_proxy all_proxy socks_proxy HTTP_PROXY HTTPS_PROXY FTP_PROXY ALL_PROXY SOCKS_PROXY"
  for envvar in ${pEnv}; do
    unset "${envvar}"
  done
  echo -e "$(c sM)all proxy environment variable has been removed.$(c)"
}

# proxy setup
# myproxy=$(echo $1 | sed -n 's/\([0-9]\{1,3\}.\)\{4\}:\([0-9]\+\)/&/p')
function pset(){
  myproxy=$( [ 0 -eq $# ] && echo 'http://127.0.0.1:8081' || echo "$*" )
  pEnv="http_proxy ftp_proxy https_proxy all_proxy HTTP_PROXY HTTPS_PROXY FTP_PROXY ALL_PROXY"
  # pEnv+="socks_proxy SOCKS_PROXY"

  for envvar in $pEnv; do
    export "${envvar}"="${myproxy}"
  done
  echo -e "$(c sG)proxy has been all set as ${myproxy}.$(c)"
}

function bd() {
  USER='svc_appbld'
  DOMAIN='engba'
  TYPE='appbuilder'

  # shellcheck disable=SC2048
  args=$(getopt rcd $*)
  if test $? != 0
  then
    echo -e 'Usage: [-r[c[d]]] HostnumVMnum
    -r: root
    -c: cdc builder (engma.veritas.com)
    -d: dev builder (appreldev)
    '
  else
    set -- $args

    for opt; do
      case ${opt} in
        -r) USER='root' ;;
        -c) DOMAIN='engma' ;;
        -d) TYPE='appreldev' ;;
      esac
    done

    for VAR in "$@"; do true; done
    HOST=${VAR:0:2}
    VM=${VAR:2}

    /usr/bin/ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -i /home/marslo/.marslo/Marslo/Tools/Softwares/sshkey/Marslo\@Appliance ${USER}@${TYPE}${HOST}-vm${VM}.${DOMAIN}.veritas.com
  fi
}

function 256color() {
  for i in {0..255}; do
    echo -e "\e[38;05;${i}mâ–ˆ${i}";
    done | column -c 80 -s ' ';
  echo -e "\e[m"
}

# function come from
function fcf() {
  if [[ 1 -ne $# ]] ; then
    echo 'Error : provide a function name'
  fi
  shopt -s extdebug; declare -F $1; shopt -u extdebug
}

# vim:ts=2:sts=2:sw=2:et:ft=sh
