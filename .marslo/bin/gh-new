#!/usr/bin/env bash
# shellcheck source=/dev/null disable=SC2155
#=============================================================================
#     FileName : gh-new
#       Author : marslo
#      Created : 2026-01-23 11:52:14
#   LastChange : 2026-02-27 19:11:29
#=============================================================================

set -euo pipefail

declare -r HERE="$( dirname "${BASH_SOURCE[0]:-$0}" )"
declare -r ME="$( basename "${BASH_SOURCE[0]:-$0}" )"

# @credit: https://github.com/ppo/bash-colors
# @usage:  or copy & paste the `c()` function from:
#          https://github.com/ppo/bash-colors/blob/master/bash-colors.sh#L3
# shellcheck disable=SC2015
test -f "${HERE}/bash-colors.sh" && source "${HERE}/bash-colors.sh" || { c() { :; }; }

declare -r USAGE="""
NAME
  $(c Cs)${ME}$(c) - smartify create a new PR with fzf or open exists PR

USAGE
  $(c Ys)\$ ${ME}$(c) $(c Wdi)[$(c)$(c Gis)OPTIONS$(c)$(c Wdi)]$(c)

OPTIONS
  $(c G)-o$(c), $(c G)--open$(c)           open the created PR in the web browser
  $(c G)-V$(c), $(c G)--verbose$(c)        show verbose output
  $(c G)-a$(c), $(c G)--auto$(c)           automatically open the current PR if exists in current branch
  $(c G)-D$(c), $(c G)--dryrun$(c)         show the command to be executed, but do not run it
  $(c G)-h$(c), $(c G)--help$(c)           show this help message
  $(c C)--$(c) $(c 0Wdi)[$(c 0Mi)GH_OPTS$(c 0Wdi)]$(c)         pass all following arguments to the underlying '$(c i)gh pr create$(c)' command

EXAMPLES
  $(c 0Wdi)# create a PR from the current branch to a selected base branch$(c)
  $(c Ys)\$ ${ME}$(c)

  $(c 0Wdi)# create a PR and open it in the web browser$(c)
  $(c Ys)\$ ${ME} $(c 0Gi)--open$(c)

  $(c 0Wdi)# open the web browser to create a pull request$(c)
  $(c Ys)\$ ${ME} $(c 0C)-- $(c 0Mi)--web$(c)

  $(c 0Wdi)# create a PR with reviewers$(c)
  $(c Ys)\$ ${ME} $(c 0C)-- $(c 0Mi)--reviewer USER,USER$(c)
"""
declare DRYRUN=false
declare VERBOSE=false
declare AUTO_OPEN=false
declare -a GH_OPTS=()
declare SHOULD_OPEN=false

function showHelp() { echo -e "${USAGE}"; exit 0; }
function joinBy {
  local d=${1-} f=${2-}
  if shift 2; then printf %s "$f" "${@/#/$d}"; fi
}
function show() {
  local tag tcolor body extra
  local bcolor="$(c 0Wi)"
  local indicator="$(c 0Wdi)>>$(c)"

  case "$1" in
    info             ) tag="$1"; shift; body="${*}"; tcolor="$(c 0Gi)";  bcolor="$(c 0Wdi)" ;;
    warning          ) tag="$1"; shift; body="${*}"; tcolor="$(c 0Yi)";  bcolor="${tcolor}" ;;
    error            ) tag="$1"; shift; body="${*}"; tcolor="$(c 0Ri)"                      ;;
    dryrun | verbose ) tag="$1"; shift; body="${*}"; tcolor="$(c 0Wdi)"; bcolor="${tcolor}" ;;
    *                ) tag='error';     body="${*}"; tcolor="$(c 0Ri)"                      ;;
  esac

  [[ 'error' == "${tag}" ]] && extra="$(c Wdi). exit ...$(c)" || extra=''
  printf "%b%b %s$(c)%b: %b$(c)%b\n" "${indicator}" "${tcolor}" "${tag^^}" "${bcolor}" "${body}" "${extra}" >&2;
  [[ 'error' == "${tag}" ]] && exit 1 || :
}

function isPushed() {
  local branch="${1:-}"
  test -z "${branch}" && show error 'branch name is required to push'

  if ! git ls-remote --exit-code --heads origin "${branch}" >/dev/null 2>&1; then
    show info "pushing branch \`$(c 0Yi)${branch}$(c 0Wdi)\` to remote ..." || :
    git push -u origin "${branch}:refs/heads/${branch}" >/dev/null
  fi
}

function prCmd() {
  # nameref
  local -n arrRef=$1

  local current="$(git branch --show-current)"
  test -z "${current}" && show error 'Not in a git repository or detached HEAD'
  isPushed "${current}"
  local gpreview="git show --color=always origin/{-1}"
  test -f "$(git rev-parse --absolute-git-dir)"/refs/remotes/origin/HEAD &&
    main="$(git symbolic-ref --short refs/remotes/origin/HEAD | sed 's|^origin/||')" ||
    main="$(gh repo view --json defaultBranchRef -q .defaultBranchRef.name)"
  local base=$({
                 echo "${main}";
                 git for-each-ref refs/remotes/origin --sort=-committerdate --format="%(refname:lstrip=3)"
               } |
               awk 'NF && $0!~/^(HEAD|origin)$/ && !seen[$0]++' |
               grep -v --color=never -E "^(${current})$" |
               fzf --no-multi --ansi --prompt='BASE BRANCH:  ' -0 \
                   --height 50% --min-height 10+ \
                   --style full --no-input-border \
                   --preview "${gpreview} -s" \
                   --preview-window=right,55%,nofollow --preview-label-pos='bottom' \
                   --bind "ctrl-o:execute(${gpreview})+change-preview(${gpreview} -s)+change-prompt( )" \
                   --bind 'ctrl-/:change-preview-window:up,60%|hidden|right,55%' \
                   --bind 'ctrl-y:execute-silent(git log origin/{-1} -1 --pretty=format:"%H" | pbcopy)'
              )

  test -z "${base:-}" && { show error 'no branch selected, aborting PR creation'; exit 1; }
  ! "${DRYRUN}" && show info "drafting PR : \`$(c 0Yi)${current}$(c 0Wdi)\` -> \`$(c 0Yi)${base}$(c 0Wdi)\`"

  local label=''
  test -z "$(gh label list --search "auto-merge")" && label='auto-merge'

  # TODO: using AI to generate better body
  local title=$(git log -1 --pretty=%s)
  local body=$(git log -1 --pretty=%B)
  test -z "${body}" && body="auto-generated PR from commit: '${title}'"

  # shellcheck disable=SC2034
  arrRef=( gh pr create
              --base "${base}"
              --head "${current}"
              --title "${title}"
              --body "${body}"
         )
  test -n "${label}" && arrRef+=( --label "${label}" )
}

function checkTools() {
  local -a tools=("gh" "fzf")
  local -a missing=()

  for tool in "${tools[@]}"; do
    type -P "${tool}" >/dev/null 2>&1 || missing+=( "${tool}" )
  done

  if [[ ${#missing[@]} -gt 0 ]]; then
    show error "missing required tools: $(c 0Mi)$(joinBy ', ' "${missing[@]}")$(c)"
  fi
}

function openPR() {
  local prId="${1:-}"
  local open="${2:-$SHOULD_OPEN}"

  if [[ 'true' = "${open}" ]]; then
    test -z "${prId}" && prId="$(gh pr view --json number -q .number 2>/dev/null)";
    # shellcheck disable=SC2015
    test -n "${prId:-}" && {
      local -a openCmd=( gh pr view "${prId}" --web )
      "${VERBOSE}" && show info "opening PR $(c 0Mi)\`#${prId}\`$(c 0Wdi) in web browser ...$(c)" || :
      "${openCmd[@]}"
    } || {
      show warning "cannot open PR: no PR ID found"
    }
  fi
}

function main() {
  while [[ $# -gt 0 ]]; do
    case "$1" in
      -o | --open    ) SHOULD_OPEN=true         ; shift        ;;
      -a | --auto    ) AUTO_OPEN=true           ; shift        ;;
      -V | --verbose ) VERBOSE=true             ; shift        ;;
      -D | --dryrun  ) DRYRUN=true              ; shift        ;;
      --             ) shift; GH_OPTS+=( "$@" ) ; break        ;;
      -h | --help    ) showHelp                                ;;
      *              ) echo "Unknown argument: $1" >&2; exit 1 ;;
    esac
  done

  checkTools

  if "${AUTO_OPEN}" && prId=$(gh pr view --json number -q .number 2>/dev/null); then
    show info "existing PR found: \`$(c 0Mi)#${prId}$(c 0Wdi)\`, opening it ...$(c)"
    openPR "${prId}" 'true'
    exit 0
  fi

  local -a cmd=()
  prCmd cmd

  ( "${DRYRUN}" || "${VERBOSE}" ) && {
    local cmdstr="${cmd[*]//$'\n'/\\\\n} ${GH_OPTS[*]}"
    local msg="command to be executed: \`$(c 0Cdi)\$ ${cmdstr}$(c 0Wdi)\` ...$(c)"
    # shellcheck disable=SC2015
    "${VERBOSE}" && show verbose "${msg}" || { show dryrun "${msg}"; exit 0; }
  }

  "${cmd[@]}" "${GH_OPTS[@]}"
  "${DRYRUN}" || openPR
}

main "$@"

# vim:tabstop=2:softtabstop=2:shiftwidth=2:expandtab:filetype=sh:
