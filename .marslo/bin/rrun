#!/usr/bin/env bash
# shellcheck source=/dev/null disable=SC2155
#=============================================================================
#     FileName : rrun
#       Author : marslo.jiao@gmail.com
#      Created : 2025-04-09 16:43:02
#   LastChange : 2025-11-07 05:00:50
#=============================================================================

set -euo pipefail

# shellcheck disable=SC2155
declare -r BIN_DIR="$( dirname "${BASH_SOURCE[0]:-$0}" )"
# @credit: https://github.com/ppo/bash-colors
# @usage:  or copy & paste the `c()` function from:
#          https://github.com/ppo/bash-colors/blob/master/bash-colors.sh#L3
# shellcheck disable=SC2015
test -f "${BIN_DIR}/bash-colors.sh" && source "${BIN_DIR}/bash-colors.sh" || { c() { :; }; }

declare FILE=''
declare CMD=''
declare USER=''
declare IPS=''
declare SSH_CONFIG_PATH="${HOME}/.ssh/config.d"
declare SSH_CONFIG="${SSH_CONFIG_PATH}/re"
declare -r ME="$(basename "${BASH_SOURCE[0]:-$0}")"
declare USAGE="
NAME
  $(c Cs)${ME}$(c) - $(c Ys)r$(c)emote $(c Ys)run$(c) - execute a local shell script or command on multiple remote hosts via SSH

USAGE
  $(c Cs)\$ ${ME}$(c) $(c Wdi)[$(c)$(c Gi)OPTIONS$(c)$(c Wdi)]$(c)

OPTIONS
  $(c G)--ip$(c) $(c Wdi)'IP1,IP2,...'$(c)             comma-separated list of target host IPs, using $(c 0Mi)\${SSH_CONFIG}$(c 0i) if not provided
  $(c G)--config$(c) $(c Wdi)'~/.ssh/config'$(c)       the $(c Bi)SSH Config$(c) file to be used
  $(c G)-n$(c), $(c G)--name$(c) $(c Wdi)'SSH_CONFIG_NAME'$(c)   the $(c Bi)SSH Config Host Alias$(c) to select hosts from $(c i)(alternative to $(c 0Mi)--config$(c 0i))$(c)
  $(c G)-u$(c), $(c G)--user$(c) $(c Wdi)'USERNAME'$(c)          the $(c Bi)SSH username$(c) for remote connection
  $(c G)-f$(c), $(c G)--file$(c) $(c Wdi)'script.sh'$(c)         local shell script to execute remotely $(c i)(alternative to $(c 0Bi)-c$(c 0i))$(c)
  $(c Ys)--$(c 0Ci) --args$(c)                      the $(c 0Mi)<SCRIPT>$(c) arguments. all arguments after $(c Ys)--$(c) will be passed to the $(c 0Mi)<SCRIPT>$(c).
  $(c G)-c$(c), $(c G)--cmd$(c) $(c Wdi)'command'$(c)            command to run directly on remote hosts $(c i)(alternative to $(c 0Bi)-f$(c 0i))$(c)
  $(c G)-q$(c), $(c G)--quiet$(c)                    quiet mode; suppress most output
  $(c G)-v$(c), $(c G)--verbose$(c)                  verbose mode; show detailed logs
  $(c G)-h$(c), $(c G)--help$(c)                     show this help message and exit

EXAMPLES
  $(c Wdi)# execute a local script with hosts filtered by fzf$(c)
  $(c Cs)\$ ${ME}$(c) $(c Gi)-f$(c) $(c Mi)/path/to/script.sh $(c 0Gi)-v$(c)

  $(c Wdi)# execute a local script on multiple remote hosts$(c)
  $(c Cs)\$ ${ME}$(c) $(c Gi)-f$(c) $(c Mi)/path/to/deploy.sh$(c) $(c Gi)--ip$(c) $(c Mi)'192.168.0.10,192.168.0.11'$(c) $(c Gi)-u$(c) $(c Mi)root$(c)

  $(c Wdi)# run a single command remotely$(c)
  $(c Cs)\$ ${ME}$(c) $(c Gi)-c$(c) $(c Mi)'uptime'$(c) $(c Gi)--ip$(c) $(c Mi)'10.0.0.1,10.0.0.2'$(c) $(c Gi)-u$(c) $(c Mi)ubuntu$(c)
"

declare NOTES="NOTES
  • $(c G)--user$(c) are mandatory if no SSH config is provided.
  • $(c Gi)--ip$(c) or $(c Gi)--config$(c) are required - $(c i)for remote hosts$(c)
  • $(c Gi)--file$(c) or $(c Gi)--cmd$(c) are required - $(c i)for remote execution$(c)
  • it's recommended to set up SSH key-based authentication or use $(c Ci)~/.ssh/config$(c) for seamless access.
"

declare quiet=false
declare verbose=false
declare -a scriptArgs=()

function showHelp() { echo -e "${USAGE}"; }
function die() { echo -e "$(c Ri)ERROR$(c)$(c i): $*.$(c) $(c Wdi)exit ...$(c)" >&2; exit 1; }
function sq()   { local s="$1"; printf "'%s'" "${s//\'/\'\"\'\"\'}"; }

while [[ $# -gt 0 ]]; do
  case "$1" in
    --ip           ) IPS="$2"           ; shift 2 ;;
    -n | --name    ) SSH_CONFIG="${SSH_CONFIG_PATH}/$2" ; shift 2 ;;
    --config       ) SSH_CONFIG="$2"    ; shift 2 ;;
    -u | --user    ) USER="$2"          ; shift 2 ;;
    -f | --file    ) FILE="$2"          ; shift 2 ;;
    -c | --cmd     ) CMD="$2"           ; shift 2 ;;
    -q | --quiet   ) quiet=true         ; shift   ;;
    -v | --verbose ) verbose=true       ; shift   ;;
    -h | --help    ) showHelp           ; exit 0  ;;
    --notes        ) echo -e "${NOTES}" ; exit 0  ;;
    --             ) shift; scriptArgs=( "$@" ); break ;;
    *              ) die "unknown option: $1"  ;;
  esac
done

[[ -z "${USER}" && -z "${SSH_CONFIG}" ]] && die "SSH username ( $(c Mi)'--user'$(c) ) is mandatory"
[[ -z "${IPS}"  && -z "${SSH_CONFIG}" ]] && die "provide a list of IPs ( $(c Mi)\`--ip\`$(c) ) or SSH config file ( $(c Mi)\`--config\`$(c) )";
[[ -z "${FILE}" && -z "${CMD}" ]] && die "provide a shell script file ( $(c Mi)\`--file\`$(c) ) or command ( $(c Mi)\`--cmd\`$(c) )to run";

[[ -n "${FILE}" ]] && [[ ! -f "${FILE}" ]] && die "$(c Mi)'--file'$(c) is not exist";
[[ -n "${SSH_CONFIG}" ]] && [[ ! -f "${SSH_CONFIG}" ]] && die "the SSH config file: $(c Ci)'${SSH_CONFIG}'$(c) is not exist";

# user@ip.address
# shellcheck disable=SC2016
[[ -z "${IPS}" ]] && IPS=$(awk '
    BEGIN {
      colorStart = "\033[37;2;3m"
      colorEnd   = "\033[0m"
    }

    # skip comments and empty lines
    /^[[:space:]]*#/ || NF==0 { next }

    function emit( i ) {
      if (n_alias > 0 && ip != "" && user != "") {
        for (i = 1; i <= n_alias; i++) {
          printf "%s@%s : %s%s%s\n", user, ip, colorStart, alias[i], colorEnd
        }
        n_alias = 0; delete alias
        ip = user = ""
      }
    }

    # new host block
    $1 == "Host" {
      emit()
      n_alias = 0; delete alias
      for (i = 2; i <= NF; i++) { if ($i ~ /^#/) break; alias[++n_alias] = $i; }
      next
    }

    $1 == "Hostname" { ip = $2; emit(); next }
    $1 == "User"     { user = $2; emit(); next }
    END { emit() }
  ' "${SSH_CONFIG}" |
  column -t |
  sort -k2 |
  fzf --prompt='󱚥 ' \
      --delimiter='[[:space:]]+:[[:space:]]+' \
      --preview '
        bash -ceu "
          user_ip=\$(cut -d : -f1 <<< \"\$1\" | xargs)
          ip=\${user_ip#*@}
          user=\${user_ip%@*}
          echo -e \"\033[36m>> HOST:\033[0m \033[3;35m\$user@\$ip\033[0m\n\"
          out=\$(/sbin/ping -c1 -o -W1 \"\$ip\" 2>&1)
          [ \$? -eq 0 ] && echo \"\$out\" || echo -e \"\033[31mUnreachable or DNS error\033[0m\"
        " _ {}
      ' |
  awk -F':' '
    {
      gsub(/^[ \t]+|[ \t]+$/, "", $1)           # trim leading/trailing whitespace
      if ($1 != "") { s = s $1 "," }            # skip empty lines
    }
    END { sub(/,$/, "", s); print s }           # remove trailing comma
  '
)

function runRemote() {
  local rType="$1"; shift
  local rTarget="$1"; shift
  local -a sshBase=()
  test "${rType}" == '<' && sshBase=(ssh -q "${ACCOUNT}@${IP}") || sshBase=(ssh -T "${ACCOUNT}@${IP}")

  # remoteStr = bash -s [-- args ...]
  local remoteStr='bash -s'
  if ((${#scriptArgs[@]})); then
    remoteStr+=' --'
    local a
    for a in "${scriptArgs[@]}"; do
      printf -v remoteStr '%s %q' "$remoteStr" "$a"
    done
  fi

  # verbose
  if "${verbose}"; then
    printf "$(c Wdi)>> %s:$(c) $(c Wi)" '[DEBUG]'
    printf '%q ' "${sshBase[@]}"
    printf '%s ' "$(sq "${remoteStr}")"
    printf '%s ' "${rType}"
    printf "%s$(c)\n" "$(sq "${rTarget}")"
  fi

  # execute
  # shellcheck disable=SC2015
  if test "${rType}" == '<'; then
    "${sshBase[@]}" "${remoteStr}" <   "${rTarget}"
  else
    "${sshBase[@]}" "${remoteStr}" <<< "${rTarget}"
  fi
}

trap exit SIGINT SIGTERM; while IFS= read -r -d ',' line; do
  [[ -z "${line}" ]] && continue
  declare name=''
  if [[ "${line}" == *@* ]]; then
    IFS='@' read -r name IP <<< "${line}"
  else
    name=''; IP="${line}"
  fi
  ACCOUNT="${USER:-${name}}"

  "${quiet}" || printf "\n$(c Wd)>>$(c) $(c Ys)%s$(c) - $(c Ys)%s$(c) $(c Wd)<<$(c)\n" "${ACCOUNT}@${IP}" "$(ssh -n "${ACCOUNT}@${IP}" 'echo $(hostname)')"

  # using sub-shell is due to setup `set -e` behavior
  # shellcheck disable=SC2205
  if [[ -n "${FILE}" ]]; then
    ( runRemote '<'   "${FILE}" ) || { "${quiet}" || printf >&2 "$(c Rdi)WARN$(c 0Wdi): %s@%s exit with non-zero$(c)\n" "${ACCOUNT}" "${IP}"; }
  else
    ( runRemote '<<<' "${CMD}"  ) || { "${quiet}" || printf >&2 "$(c Rdi)WARN$(c 0Wdi): %s@%s exit with non-zero$(c)\n" "${ACCOUNT}" "${IP}"; }
  fi

done <<< "${IPS},"

# vim:tabstop=2:softtabstop=2:shiftwidth=2:expandtab:filetype=sh:
